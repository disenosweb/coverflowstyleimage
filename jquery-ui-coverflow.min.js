/* Copyright (c) 2015 Planet Telex Inc. all rights reserved. Licence: http://www.apache.org/licenses/LICENSE-2.0 */
"undefined" != typeof jQuery && "undefined" != typeof jQuery.ui && function (t) { Math.degreesToRadians = function (t) { return t * (Math.PI / 180) }, t.widget("pt.cover", { widgetEventPrefix: "pt.cover", options: { id: (new Date).getTime() * Math.random(), width: 300, height: 300, patchSize: 70, perspective: { angle: 0, enabled: !0, position: "center" }, subdivisionLimit: 3, animation: { slide: { duration: 900, easing: "easeOutCirc" }, perspective: { duration: 120, easing: "swing" } }, canvas: { background: "white", left: 0, top: 0, zIndex: 0, opacity: 1 }, reflection: { enabled: !0, initialOpacity: 50, length: 80 }, title: { enabled: !0 } }, _create: function () { this.options.refreshState = this._refreshState, 1 === this.element[0].nodeType && "img" === this.element[0].tagName.toLowerCase() && "" !== this.element[0].src && (this.element[0].complete || 4 === this.element[0].readyState ? this._load() : "uninitialized" === this.readyState && 0 === this.src.indexOf("data:") ? this.element.trigger("error") : this.element.load(this._load.bind(this))) }, _setOption: function () { t.Widget.prototype._setOption.apply(this, arguments) }, destroy: function () { this.supportsCanvas && this._$cover ? this._$cover.remove() : this.element.unbind().css({ visibility: this._previousVisibility, opacity: "", background: "", top: "", left: "", zIndex: "", textIndent: "", position: "", cursor: "" }), this._hasTitle() && this._$titleContainer.remove(), t.Widget.prototype.destroy.call(this) }, _$cover: null, _drawing: null, _previousOptions: null, _previousVisibility: null, _cachedCanvas: null, _refreshState: 1, _$titleContainer: null, supportsCanvas: function () { var t = document.createElement("canvas"); return !(!t.getContext || !t.getContext("2d")) }(), left: function () { var t = this._height(), i = [[0, 0], [this.options.width, this._skewLength()], [0, t], [this.options.width, t - this._skewLength()]]; this._draw(i) }, center: function () { var t = this._height(), i = [[0, 0], [this.options.width, 0], [0, t], [this.options.width, t]]; this._draw(i) }, right: function () { var t = this._height(), i = [[0, this._skewLength()], [this.options.width, 0], [0, t - this._skewLength()], [this.options.width, t]]; this._draw(i) }, refresh: function (t) { t = t || !1, ++this.options.refreshState, this._hasTitle() && ("center" == this.options.perspective.position ? this._$titleContainer.show() : this._$titleContainer.hide()), t ? this._$cover.css({ zIndex: this.options.canvas.zIndex, top: this.options.canvas.top }).animate({ left: this.options.canvas.left, opacity: this.options.canvas.opacity }, { queue: !1, duration: this.options.animation.slide.duration, easing: this.options.animation.slide.easing, complete: this._animateLeftComplete.bind(this) }).animate({ textIndent: "center" == this.options.perspective.position ? 0 : this.options.perspective.angle }, { queue: !1, duration: this.options.animation.perspective.duration, easing: this.options.animation.perspective.easing, step: this._animateAngleStep.bind(this), complete: this._animateAngleComplete.bind(this) }) : (this._$cover.css({ zIndex: this.options.canvas.zIndex, top: this.options.canvas.top, left: this.options.canvas.left, opacity: this.options.canvas.opacity }), this._perspective(), this._syncRefreshState(), this._triggerRefreshed()) }, raiseZ: function () { ++this.options.canvas.zIndex, this._$cover.css({ zIndex: this.options.canvas.zIndex }) }, lowerZ: function () { --this.options.canvas.zIndex, this._$cover.css({ zIndex: this.options.canvas.zIndex }) }, _animateAngleStep: function (t, i) { if ("textIndent" == i.prop) { var e = this._previousOptions.perspective.position; "center" == e && (e = this.options.perspective.position), this.options.perspective.angle = t, this._perspective(e) } }, _animateAngleComplete: function () { this._perspective(), this._syncRefreshState() }, _animateLeftComplete: function () { this._triggerRefreshed() }, _height: function () { var t = this.options.height; return this.options.reflection.enabled && (t *= 2), t }, _skewLength: function () { return Math.tan(Math.degreesToRadians(this.options.perspective.angle)) * this.options.width }, _load: function () { this._$cover = this.element, this.supportsCanvas && (this._$cover = t("<canvas/>")), this._$cover.attr({ width: this.options.width, height: this.options.height }).css({ opacity: this.options.canvas.opacity, background: this.options.canvas.background, top: this.options.canvas.top, left: this.options.canvas.left, zIndex: this.options.canvas.zIndex, textIndent: this.options.perspective.angle, position: "absolute", cursor: "pointer" }).click(this._click.bind(this)).mouseenter(this._mouseenter.bind(this)).mouseleave(this._mouseleave.bind(this)), this.supportsCanvas ? (this.element.css({ top: -1e3, left: -1e3, position: "absolute" }).after(this._$cover), this._drawing = new i.Drawing(this._$cover[0], this.options), this._drawing.importImage(this.element[0]), this.options.reflection.enabled && this._drawing.addMirror(), this._cachedCanvas = this._drawing.cloneCanvas()) : (this._previousVisibility = this.element.css("visibility"), this.element.css({ visibility: "visible" })), this.options.title.enabled && (this._$titleContainer = t("<div/>").addClass("cover-title").append(t("<h1/>").text(this.element.data("title"))).append(t("<h2/>").text(this.element.data("subtitle"))).hide(), this.element.after(this._$titleContainer)), this.refresh() }, _click: function (t) { this._trigger("click", t, { image: this.element }) }, _mouseenter: function (t) { this._trigger("mouseenter", t, { image: this.element }) }, _mouseleave: function (t) { this._trigger("mouseleave", t, { image: this.element }) }, _draw: function (t) { this.supportsCanvas ? (this._drawing.perspective(t, this._cachedCanvas, !this.options.reflection.enabled), this.options.reflection.enabled && this._drawing.addMirrorReflection()) : this._$cover.attr({ width: this.options.width, height: this.options.height }) }, _hasTitle: function () { return this.options.title.enabled && this._$titleContainer }, _perspective: function (t) { t = t || this.options.perspective.position, this._previousOptions && this._previousOptions.perspective.position == this.options.perspective.position || (this.options.perspective.enabled ? this[t]() : this.center()) }, _syncRefreshState: function () { this.options.refreshState - this._refreshState <= 1 && (this._previousOptions = t.extend(!0, {}, this.options)), ++this._refreshState }, _triggerRefreshed: function () { this._trigger("refreshed-" + this.options.id, null, { image: this.element }) } }); var i = i || {}; i.Drawing = function (i, e) { this.canvas = i, this.ctx = this.canvas.getContext("2d"), this.options = t.extend({ subdivisionLimit: 3, patchSize: 70, reflection: { initialOpacity: 50, length: 80 } }, e), this.transform = null, this.iw = 0, this.ih = 0 }, i.Drawing.prototype.cloneCanvas = function () { var t = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height), i = document.createElement("canvas"); i.width = this.canvas.width, i.height = this.canvas.height; var e = i.getContext("2d"); return e.putImageData(t, 0, 0), i }, i.Drawing.prototype.importImage = function (t) { this.ctx.drawImage(t, 0, 0, this.canvas.width, this.canvas.height) }, i.Drawing.prototype.perspective = function (i, s, n) { this.image = s || this.cloneCanvas(); var o = 1 / 0, a = -1 / 0, h = 1 / 0, r = -1 / 0; t.each(i, function () { o = Math.min(o, Math.floor(this[0])), a = Math.max(a, Math.ceil(this[0])), h = Math.min(h, Math.floor(this[1])), r = Math.max(r, Math.ceil(this[1])) }); var c = a - o, p = r - h; this.canvas.width = c, this.canvas.height = p, this.iw = this.image.width, this.ih = this.image.height, this.ctx.translate(-o, -h), this.ctx.clearRect(o, h, c, p), this.transform = e.getProjectiveTransform(i); var l = this.transform.transformProjectiveVector([0, 0, 1]), v = this.transform.transformProjectiveVector([1, 0, 1]), d = this.transform.transformProjectiveVector([0, 1, 1]), f = this.transform.transformProjectiveVector([1, 1, 1]); n && (this.ctx.beginPath(), this.ctx.moveTo(l[0], l[1]), this.ctx.lineTo(v[0], v[1]), this.ctx.lineTo(f[0], f[1]), this.ctx.lineTo(d[0], d[1]), this.ctx.closePath(), this.ctx.clip()), this.divide(0, 0, 1, 1, l, v, d, f, this.options.subdivisionLimit) }, i.Drawing.prototype.addMirror = function () { var t = this.cloneCanvas(); this.canvas.height *= 2, this.ctx.drawImage(t, 0, 0), this.ctx.save(), this.ctx.translate(0, this.canvas.height), this.ctx.scale(1, -1), this.ctx.drawImage(t, 0, 0), this.ctx.restore() }, i.Drawing.prototype.addMirrorReflection = function () { var t = Math.floor(this.canvas.height / 2), i = this.options.reflection.initialOpacity / 100, e = this.options.reflection.length / 100; this.ctx.save(), this.ctx.globalCompositeOperation = "destination-out"; var s = this.ctx.createLinearGradient(0, t, 0, this.canvas.height); s.addColorStop(0, "rgba(255, 255, 255, " + (1 - i) + ")"), s.addColorStop(e, "rgba(255, 255, 255, 1.0)"), s.addColorStop(1, "rgba(255, 255, 255, 1.0)"), this.ctx.fillStyle = s, this.ctx.rect(0, t, this.canvas.width, t), this.ctx.fill(), this.ctx.restore() }, i.Drawing.prototype.divide = function (t, i, e, s, n, o, a, h, r) { if (r) { var c = [o[0] + a[0] - 2 * n[0], o[1] + a[1] - 2 * n[1]], p = [o[0] + a[0] - 2 * h[0], o[1] + a[1] - 2 * h[1]], l = [c[0] + p[0], c[1] + p[1]], v = Math.abs((l[0] * l[0] + l[1] * l[1]) / (c[0] * p[0] + c[1] * p[1])); c = [o[0] - n[0] + h[0] - a[0], o[1] - n[1] + h[1] - a[1]], p = [a[0] - n[0] + h[0] - o[0], a[1] - n[1] + h[1] - o[1]]; var d = Math.abs(c[0] * p[1] - c[1] * p[0]); if (0 === t && 1 == e || (.25 + 5 * v) * d > this.options.patchSize * this.options.patchSize) { var f = (t + e) / 2, u = (i + s) / 2, g = this.transform.transformProjectiveVector([f, u, 1]), m = this.transform.transformProjectiveVector([f, i, 1]), _ = this.transform.transformProjectiveVector([f, s, 1]), w = this.transform.transformProjectiveVector([t, u, 1]), x = this.transform.transformProjectiveVector([e, u, 1]); return r--, this.divide(t, i, f, u, n, m, w, g, r), this.divide(f, i, e, u, m, o, g, x, r), this.divide(t, u, f, s, w, g, a, _, r), void this.divide(f, u, e, s, g, x, _, h, r) } } this.ctx.save(), this.ctx.beginPath(), this.ctx.moveTo(n[0], n[1]), this.ctx.lineTo(o[0], o[1]), this.ctx.lineTo(h[0], h[1]), this.ctx.lineTo(a[0], a[1]), this.ctx.closePath(); var b = [o[0] - n[0], o[1] - n[1]], y = [h[0] - o[0], h[1] - o[1]], M = [a[0] - h[0], a[1] - h[1]], C = [n[0] - a[0], n[1] - a[1]], I = Math.abs(b[0] * C[1] - b[1] * C[0]), S = Math.abs(y[0] * b[1] - y[1] * b[0]), z = Math.abs(M[0] * y[1] - M[1] * y[0]), $ = Math.abs(C[0] * M[1] - C[1] * M[0]), P = Math.max(Math.max(I, S), Math.max($, z)), T = 0, k = 0, j = 0, V = 0; switch (P) { case I: this.ctx.transform(b[0], b[1], -C[0], -C[1], n[0], n[1]), 1 != e && (j = 1.05 / Math.sqrt(b[0] * b[0] + b[1] * b[1])), 1 != s && (V = 1.05 / Math.sqrt(C[0] * C[0] + C[1] * C[1])); break; case S: this.ctx.transform(b[0], b[1], y[0], y[1], o[0], o[1]), 1 != e && (j = 1.05 / Math.sqrt(b[0] * b[0] + b[1] * b[1])), 1 != s && (V = 1.05 / Math.sqrt(y[0] * y[0] + y[1] * y[1])), T = -1; break; case z: this.ctx.transform(-M[0], -M[1], y[0], y[1], h[0], h[1]), 1 != e && (j = 1.05 / Math.sqrt(M[0] * M[0] + M[1] * M[1])), 1 != s && (V = 1.05 / Math.sqrt(y[0] * y[0] + y[1] * y[1])), T = -1, k = -1; break; case $: this.ctx.transform(-M[0], -M[1], -C[0], -C[1], a[0], a[1]), 1 != e && (j = 1.05 / Math.sqrt(M[0] * M[0] + M[1] * M[1])), 1 != s && (V = 1.05 / Math.sqrt(C[0] * C[0] + C[1] * C[1])), k = -1 } var O = e - t, L = s - i, D = j * O, R = V * L; this.ctx.drawImage(this.image, t * this.iw, i * this.ih, Math.min(e - t + D, 1) * this.iw, Math.min(s - i + R, 1) * this.ih, T, k, 1 + j, 1 + V), this.ctx.restore() }; var e = function (t) { this.w = t[0] ? t[0].length : 0, this.h = t.length, this.values = t }; e.getProjectiveTransform = function (t) { var i = new e([[1, 1, 1, 0, 0, 0, -t[3][0], -t[3][0], -t[3][0]], [0, 1, 1, 0, 0, 0, 0, -t[2][0], -t[2][0]], [1, 0, 1, 0, 0, 0, -t[1][0], 0, -t[1][0]], [0, 0, 1, 0, 0, 0, 0, 0, -t[0][0]], [0, 0, 0, -1, -1, -1, t[3][1], t[3][1], t[3][1]], [0, 0, 0, 0, -1, -1, 0, t[2][1], t[2][1]], [0, 0, 0, -1, 0, -1, t[1][1], 0, t[1][1]], [0, 0, 0, 0, 0, -1, 0, 0, t[0][1]]]), s = i.rowEchelon().values, n = new e([[-s[0][8], -s[1][8], -s[2][8]], [-s[3][8], -s[4][8], -s[5][8]], [-s[6][8], -s[7][8], 1]]); return n }, e.cloneValues = function (t) { for (var i = [], e = 0; e < t.length; ++e) i[e] = [].concat(t[e]); return i }, e.prototype.transformProjectiveVector = function (t) { var i, e = []; for (i = 0; i < this.h; ++i) { e[i] = 0; for (var s = 0; s < this.w; ++s) e[i] += this.values[i][s] * t[s] } var n = 1 / e[e.length - 1]; for (i = 0; i < this.h; ++i) e[i] *= n; return e }, e.prototype.rowEchelon = function () { if (this.w <= this.h) throw "Matrix rowEchelon size mismatch"; for (var t = e.cloneValues(this.values), i = 0; i < this.h; ++i) { for (var s = t[i][i]; 0 === s;) { for (var n = i + 1; n < this.h; ++n) if (0 !== t[n][i]) { var o = t[n]; t[n] = t[i], t[i] = o; break } if (n == this.h) return new e(t); s = t[i][i] } var a, h = 1 / s; for (a = i; a < this.w; ++a) t[i][a] *= h; for (var r = 0; r < this.h; ++r) if (r != i) { var c = t[r][i]; for (t[r][i] = 0, a = i + 1; a < this.w; ++a) t[r][a] -= c * t[i][a] } } return new e(t) }, Function.prototype.bind || (Function.prototype.bind = function (t) { if ("function" != typeof this) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable"); var i = Array.prototype.slice.call(arguments, 1), e = this, s = function () { }, n = function () { return e.apply(this instanceof s ? this : t || window, i.concat(Array.prototype.slice.call(arguments))) }; return s.prototype = this.prototype, n.prototype = new s, n }) }(jQuery);
"undefined" != typeof jQuery && "undefined" != typeof jQuery.ui && function (e) { var t = { left: 1, center: 2, right: 3 }; e.widget("pt.coverflow", { widgetEventPrefix: "pt.coverflow", options: { width: null, height: null, selectedIndex: 0, autoplay: { enabled: !1, interval: 3, pauseOnMouseenter: !0, playsPerCategory: 3 }, categories: { enabled: !1, defaultCategory: "Unknown", selectedCategory: null, renderTitles: !0, rememberLastCover: !0, delAnimationCount: 4, addAnimationRadius: 4 }, cover: { height: 300, width: 300, animation: { perspective: { duration: 80, inner: 120 }, radius: 20 }, background: { style: null, size: 90, overlap: { inner: 20, outer: 80 } }, perspective: { angle: 12, enabled: !0 }, reflection: { enabled: !0, initialOpacity: 30, length: 80 }, title: { enabled: !0 } }, images: [], slider: { enabled: !0, width: 80 } }, _create: function () { if (this._categories = [], this._categoryData = {}, this.options.width = this.options.width || this.element.width(), this.options.height = this.options.height || this.element.height(), e().slider || (this.options.slider = !1), this._currentIndex = this.options.selectedIndex, this.options.images.length > 0) { var t, i, s = null; for (s in this.options.images) t = this.options.images[s], i = "", t.title && (i = t.title), t.subtitle && ("" !== i && (i += ", "), i += t.subtitle), this.element.append(e("<img/>").attr({ src: t.src, alt: i }).data({ title: t.title, subtitle: t.subtitle, category: t.category })) } this.element.css({ position: "relative", overflow: "hidden" }), this._$images = this.element.find("img"), this._loadImages(), this._loadSlider(), this.options.categories.enabled && (this._setCurrentCategory(this.options.categories.selectedCategory), this._loadCategoryTitles()), this.options.autoplay.enabled && this._play() }, _setOption: function (t, i) { switch (t) { case "selectedIndex": this._gotoCover(i); break; case "categories": i.selectedCategory != this.options.categories.selectedCategory && this._gotoCategory(i.selectedCategory); break; case "autoplay": i.enabled ? this._play() : this._pause() } e.Widget.prototype._setOption.apply(this, arguments) }, destroy: function () { this._pause(), this._$images.each(function (t, i) { e(i).cover("destroy") }), this._$categories && this._$categories.remove(), this._$slider && this._$slider.slider("destroy").remove(), this.element.unbind().css({ position: "", overflow: "" }), e.Widget.prototype.destroy.call(this) }, _$activeImages: [], _categories: [], _$categories: null, _$images: [], _categoryData: {}, _isPauseManual: !1, _$slider: null, _$sliderHandleHelper: null, _currentIndex: 0, _currentCategoryIndex: 0, _playIntervalId: null, _playCountInCategory: 0, addImage: function (e, t) { t = "undefined" == typeof t ? !0 : t, this._addImage(e, !1, t), this._trigger("imageAdded", null, { selectedIndex: this._currentIndex }) }, _addImage: function (i, s, n) { if (s = s || !1, !i.data("pt-cover")) { this._$activeImages.each(function (t, i) { e(i).cover("raiseZ") }), i.remove(), this.element.append(i); var o = this._loadImage(i[0]); (s || !this.options.categories.enabled || this._getCurrentCategory() == o) && (this._$activeImages.push(i[0]), this._createCover(this._imagesCount() - 1, i[0], t.right), this._updateCover(n, !0, this._currentIndex, this._imagesCount() - 1, i[0], t.center), this._syncSlider()) } }, removeImage: function (e) { e = "undefined" == typeof e ? !0 : e, this._imagesCount() > 1 && (this._removeImage(!1, e), this._trigger("imageRemoved", null, { selectedIndex: this._currentIndex })) }, _removeImage: function (i, s) { var n = 0, o = this._$activeImages.splice(n, 1); this.element.one("pt.coverrefreshed-" + e(o).data("pt-coverflow").id, function (t, i) { e(i.image).cover("destroy") }), this._updateCover(s, !0, this._currentIndex, n, o, t.left), this._$activeImages.each(function (t, i) { e(i).cover("lowerZ"), e(i).data("pt-coverflow").index = t }); var r; return r = n == this._currentIndex ? this._currentIndex : this._currentIndex - 1, i ? this._currentIndex = r : this._gotoCover(r, !0), this._syncSlider(), o }, isPlaying: function () { return null !== this._playIntervalId }, play: function () { this._isPauseManual = !1; var t = e.extend(!0, {}, this.options.autoplay); t.enabled = !0, this._setOption("autoplay", t), this._trigger("play", null, { selectedIndex: this._currentIndex }) }, _play: function () { this.isPlaying() || (this._playIntervalId = setInterval(this._playNext.bind(this), 1e3 * this.options.autoplay.interval)) }, _playNext: function () { if (this.options.categories.enabled) { if (this._playCountInCategory > this._imagesCount() || this._playCountInCategory >= this.options.autoplay.playsPerCategory - 1) return this.nextCategory(), void (this._playCountInCategory = 0); ++this._playCountInCategory } this._nextCover() }, pause: function () { this._isPauseManual = !0, this._pause(), this._trigger("pause", null, { selectedIndex: this._currentIndex }) }, _pause: function () { this.isPlaying() && (clearInterval(this._playIntervalId), this._playIntervalId = null) }, togglePlay: function () { if (this.isPlaying()) this._isPauseManual = !0, this._pause(); else { this._isPauseManual = !1; var t = e.extend(!0, {}, this.options.autoplay); t.enabled = !0, this._setOption("autoplay", t) } this._trigger("togglePlay", null, { selectedIndex: this._currentIndex }) }, _setCurrentCategory: function (e) { if (e) for (var t = 0; t < this._categories.length; t++) if (this._categories[t] == e) { this._currentCategoryIndex = t; break } }, _getCurrentCategory: function () { return this._categories[this._currentCategoryIndex] }, nextCategory: function () { this.options.categories.enabled && (this._nextCategory(), this._trigger("nextCategory", null, { selectedCategory: this._getCurrentCategory() })) }, _nextCategory: function () { var e; e = this._currentCategoryIndex == this._categories.length - 1 ? 0 : this._currentCategoryIndex + 1, e != this._currentCategoryIndex && this._gotoCategory(this._categories[e]) }, prevCategory: function () { this.options.categories.enabled && (this._prevCategory(), this._trigger("prevCategory", null, { selectedCategory: this._getCurrentCategory() })) }, _prevCategory: function () { var e; e = 0 === this._currentCategoryIndex ? this._categories.length - 1 : this._currentCategoryIndex - 1, this._gotoCategory(this._categories[e]) }, gotoCategory: function (t) { if (this.options.categories.enabled) { var i = e.extend(!0, {}, this.options.categories); i.selectedCategory = t, this._setOption("categories", i), this._trigger("gotoCategory", null, { selectedCategory: this._getCurrentCategory() }) } }, _gotoCategory: function (t) { var i = this._categoryData[t].images; if (i && i.length > 0) { var s, n, o = !0, r = this._imagesCount(); for (n = 0; r > n; n++) this._removeImage(o, n + 1 > this.options.categories.delAnimationCount ? !1 : !0); (this.options.autoplay.enabled && !this._isPauseManual || this.options.categories.rememberLastCover) && (this._currentIndex = this._categoryData[t].selectedIndex); var a = Math.max(0, this._currentIndex - this.options.categories.addAnimationRadius), h = Math.min(i.length - 1, this._currentIndex + this.options.categories.addAnimationRadius); for (n = 0; n < i.length; n++) s = n >= a && h >= n, this._addImage(e(i[n]), o, s); this._setCurrentCategory(t), this.options.categories.selectedCategory = t, this._loadCategoryTitles() } }, nextCover: function () { this._nextCover(), this._trigger("nextCover", null, { selectedIndex: this._currentIndex }) }, _nextCover: function () { var e; e = this._currentIndex == this._imagesCount() - 1 ? 0 : this._currentIndex + 1, this._gotoCover(e) }, prevCover: function () { this._prevCover(), this._trigger("prevCover", null, { selectedIndex: this._currentIndex }) }, _prevCover: function () { var e; e = 0 === this._currentIndex ? this._imagesCount() - 1 : this._currentIndex - 1, this._gotoCover(e) }, gotoCover: function (e) { this._setOption("selectedIndex", e), this._trigger("gotoCover", null, { selectedIndex: this._currentIndex }) }, _gotoCover: function (e, t) { t = t || !1, this.options.slider.enabled && !t && this._$slider.slider("value", e); var i, s, n = Math.max(0, e - this.options.cover.animation.radius), o = Math.min(this._$activeImages.length - 1, e + this.options.cover.animation.radius); for (i = 0; i < this._$activeImages.length; i++) s = i >= n && o >= i, this._updateCover(s, t, e, i, this._$activeImages[i]); if (this._currentIndex = e, this.options.categories.enabled) { var r = this._getCurrentCategory(); this._categoryData[r].selectedIndex = e } this._currentIndex == this._imagesCount() && this._trigger("lastCover", null, { selectedIndex: this._currentIndex }) }, _createCover: function (i, s, n) { n = n || t.center; var o = !1, r = this._coverConfig(this._currentIndex, i, n, o, { id: (new Date).getTime() * Math.random(), click: this._clickCover.bind(this), mouseenter: this._autoplayMouseEnter.bind(this), mouseleave: this._autoplayMouseLeave.bind(this) }); e(s).show().cover(r).data("pt-coverflow", { index: i, id: r.id }) }, _loadImages: function () { for (var t = 0; t < this._$images.length; t++) this._loadImage(this._$images[t], !0); this.options.categories.enabled ? (this.options.categories.selectedCategory || (this.options.categories.selectedCategory = this._categories[0]), this._categoryData[this.options.categories.selectedCategory].selectedIndex = this._currentIndex, this._$activeImages = e(this._categoryData[this.options.categories.selectedCategory].images)) : this._$activeImages = this._$images, this._$activeImages.each(this._createCover.bind(this)) }, _loadImage: function (t, i) { i = i || !1; var s = e(t).hide(), n = null; return this.options.categories.enabled && (n = s.data("category"), n || (n = this.options.categories.defaultCategory), i && (this._categoryData[n] || (this._categoryData[n] = { selectedIndex: 0, images: [] }, this._categories.push(n)), this._categoryData[n].images.push(t))), n }, _updateCover: function (i, s, n, o, r, a) { a = a || t.center; var h = this._coverConfig(n, o, a, s); a == t.left ? (h.canvas.opacity = 0, h.animation.slide.easing = "swing") : h.canvas.opacity = 1; var l = e(r).data("pt-cover"); for (var d in h) l.option(d, h[d]); l.refresh(i) }, _sliderChange: function (e, t) { t.value != this._currentIndex && (this._gotoCover(t.value, !0), this._trigger("slide", null, { selectedIndex: this._currentIndex })) }, _clickCover: function (e, t) { var i = t.image.data("pt-coverflow").index, s = this._currentIndex; this._gotoCover(i); var n = "backgroundCoverClick"; i == s && (n = "selectedCoverClick"), this._trigger(n, null, { lastIndex: s, selectedIndex: this._currentIndex, image: t.image }) }, _autoplayMouseEnter: function () { this.options.autoplay.pauseOnMouseenter && this._pause(), this._trigger("mouseenter", null, { selectedIndex: this._currentIndex }) }, _autoplayMouseLeave: function () { this.options.autoplay.pauseOnMouseenter && this.options.autoplay.enabled && !this._isPauseManual && this._play(), this._trigger("mouseleave", null, { selectedIndex: this._currentIndex }) }, _coverConfig: function (i, s, n, o, r) { n = n || t.center, r = r || {}; var a = 0, h = "center", l = 0; i > s ? (a = -1 * (i - s), h = "left") : s > i && (a = s - i, h = "right"), s != i && (l = 1 - this.options.cover.background.size / 100); var d = this.options.cover.animation.perspective.duration; o || 1 != Math.abs(this._currentIndex - i) || (d += d * (this.options.cover.animation.perspective.inner / 100)); var c = this.options.cover.width - l * this.options.cover.width, g = this.options.cover.height - l * this.options.cover.height, u = e.extend(!0, {}, this.options.cover, r, { perspective: { position: h }, width: c, height: g, canvas: { background: this.options.cover.background.style || this.element.css("background-color"), left: this._coverLeft(a, c, n), top: this._coverTop(a, g, l), zIndex: this._$activeImages.length - Math.abs(a) }, animation: { slide: { duration: 900, easing: "easeOutCirc" }, perspective: { duration: d, easing: "swing" } } }); return u }, _coverLeft: function (e, i, s) { var n = 0; switch (s) { case t.center: n = this.options.width / 2 - i / 2 + i * e; var o; Math.abs(e) > 1 ? (o = this.options.cover.background.overlap.outer / 100 * i, o *= Math.abs(e) - 1, o += this.options.cover.background.overlap.inner / 100 * i) : (o = this.options.cover.background.overlap.inner / 100 * i, o *= Math.abs(e)), 0 > e ? n += o : e > 0 && (n -= o); break; case t.right: n = this.options.width - i } return n }, _coverTop: function (e, t, i) { var s = 0; return 0 !== e && (s += t * (i / 2)), s }, _imagesCount: function () { return this._$activeImages.length }, _loadCategoryTitles: function () { if (this.options.categories.renderTitles) { this._$categories && this._$categories.remove(), this._$categories = e("<ul />").addClass("coverflow-categories"); for (var t in this._categories) { var i = this._categories[t], s = e("<li />").text(i).click(e.curry(this, "gotoCategory", i)); i == this._getCurrentCategory() && s.addClass("coverflow-selected-category"), this._$categories.append(s) } this.element.before(this._$categories) } }, _loadSlider: function () { if (this.options.slider.enabled) { var t = this._imagesCount(), i = this.options.width - (1 - this.options.slider.width / 100) * this.options.width, s = i / t; this._$slider = e("<div />").bind("mouseenter", this._autoplayMouseEnter.bind(this)).bind("mouseleave", this._autoplayMouseLeave.bind(this)).css({ width: i, position: "absolute", zIndex: t + 1, left: (this.options.width - i) / 2 }).addClass("coverflow-slider").slider({ animate: !0, value: this._currentIndex, max: t - 1, slide: this._sliderChange.bind(this) }), this._$sliderHandleHelper = this._$slider.find(".ui-slider-handle").css({ width: s, marginLeft: -s / 2 - 2 }).wrap(e("<div class='ui-handle-helper-parent'></div>").width(i - s).css({ position: "relative", height: "100%", margin: "auto" })).parent(), this.element.append(this._$slider) } }, _syncSlider: function () { if (this.options.slider.enabled) { var e = this._imagesCount(); if (!(2 > e)) { this._$slider.css({ zIndex: e + 1 }).slider("option", "max", e - 1).slider("value", this._currentIndex); var t = this.options.width - (1 - this.options.slider.width / 100) * this.options.width, i = t / e; this._$sliderHandleHelper.width(t - i).find("a").css({ width: i, marginLeft: -i / 2 - 2 }) } } } }), e.curry = function (t, i) { var s = null, n = Array.prototype.slice.call(arguments, 2); return arguments.length >= 2 && ("string" == typeof i ? (s = t, t = s[i], i = void 0) : i && !e.isFunction(i) && (s = i, i = void 0)), !i && t && (i = function () { var i = e.merge([], n); return i = e.merge(i, arguments), t.apply(s || this, i) }), t && (i.guid = t.guid = t.guid || i.guid || e.guid++), i } }(jQuery);
